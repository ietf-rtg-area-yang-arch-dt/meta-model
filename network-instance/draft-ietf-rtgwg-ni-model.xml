<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  ]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>
<rfc category="std" ipr="trust200902" docName="draft-ietf-rtgwg-ni-model-03" >

<front>
<title abbrev="YANG NIs">YANG Network Instances</title>
    <author initials='L.' surname="Berger" fullname='Lou Berger'>
     <organization>LabN Consulting, L.L.C.</organization>
     <address>
       <email>lberger@labn.net</email>
    </address>
    </author>
   <author initials='C.' surname="Hopps" fullname='Christan Hopps'>
    <organization>Deutsche Telekom</organization>
     <address>
       <email>chopps@chopps.org</email>
    </address>
    </author>
   <author initials='A.' surname="Lindem" fullname='Acee Lindem'>
    <organization>Cisco Systems</organization>
    <address>
      <postal>
        <street>301 Midenhall Way</street>
        <city>Cary</city> <region>NC</region>
        <country>USA</country>
        <code>27513</code>
       </postal>
       <email>acee@cisco.com</email>
    </address>
    </author>
   <author initials='D.' surname="Bogdanovic" fullname='Dean Bogdanovic'>
    <organization></organization>
     <address>
       <email>ivandean@gmail.com</email>
    </address>
    </author>
   <author initials='X.' surname="Liu" fullname='Xufeng Liu'>
    <organization>Jabil</organization>
     <address>
       <email>Xufeng_Liu@jabil.com</email>
    </address>
    </author>

  <date/>
  <abstract>
<t>
  This document defines a network instance module. This module
  can be used to manage the
  virtual resource partitioning that may be present on a
  network device. Examples of
  common industry terms for virtual resource partitioning are Virtual
  Routing and Forwarding (VRF) instances and Virtual Switch Instances
  (VSIs).
</t>
</abstract>
</front>

<middle>
<section anchor="sec-1" title="Introduction">
<t>
   This document defines the second of two new modules that are defined
   to support the configuration and operation of network-devices that
   allow for the partitioning of resources from both, or either,
   management and networking perspectives.  Both make use of the
   YANG functionality enabled by YANG Schema Mount <xref
   target="I-D.ietf-netmod-schema-mount"/>.
</t>
<t>
   Two forms of resource partitioning are supported:
</t>
<t>
   The first form
   provides a logical partitioning of a network device where each
   partition is separately managed as essentially an independent
   network element which is 'hosted' by the base network device.
   These hosted network elements are referred to as logical
   network elements, or LNEs, and are supported by the
   logical-network-element module defined in <xref target="I-D.ietf-rtgwg-lne-model"/>.
   The module is used to identify LNEs and associate resources from the
   network-device with each LNE.  LNEs themselves are represented
   in YANG as independent network devices; each accessed
   independently.  Optionally, and when supported by the
   implementation, they may also be accessed from the host system.
   Examples of vendor terminology for an LNE include logical
   system or logical router, and virtual switch, chassis, or fabric.
</t>
<t>
   The second form, which is defined in this document, provides
   support what is commonly referred to as Virtual Routing and
   Forwarding (VRF) instances as well as Virtual Switch Instances
   (VSI), see <xref target="RFC4026"/>.  In this form of resource
   partitioning multiple control plane and forwarding/bridging
   instances are provided by and managed via a single (physical or
   logical) network device.  This form of resource partitioning is
   referred to as Network Instances and are supported by the
   network-instance module defined below.  Configuration and
   operation of each network-instance is always via the network
   device and the network-instance module.
</t>
<section anchor="sec-1.1" title="Status of Work and Open Issues">
<t>
The top open issues are:
  <list style="numbers">
    <t>
      The "policy" definitions related to the (core) support of VRFs and
      VSIs is TBD.  This could be defined based on the L2SM and L3SM.
    </t>
    <t>
      The current definition of schema mount has schema definition tied
      to a mount point. This implies that it would be beneficial to have
      different mount points for different types of NIs, e.g., VRF vs
      VSI vs VSI+VRF.  Resolving this is TBD.
    </t>
    <t>
      Schema mount currently doesn't allow parent-reference filtering on
      the instance of  mount point, but rather just the schema.  This
      means it is not possible to filter based on actual data, e.g.,
      bind-network-instance-name="green".  If the schema mount
      definition, the text and examples should be updated to cover this
      case.
    </t>
    <t>
      Close on other TBDs in doc/module, e.g., RPCs and notifications.
   </t>
   </list>
 </t>
</section>
</section>
<section anchor="sec-2" title="Overview">
<t>
   In this document, we consider network devices that support protocols
   and functions defined within the IETF Routing Area, e.g, routers,
   firewalls and hosts. Such devices may be physical or virtual, e.g., a
   classic router with custom hardware or one residing within a
   server-based virtual machine implementing a virtual network function
   (VNF). Each device may sub-divide their resources into logical
   network elements (LNEs) each of which provides a managed logical
   device.  Examples of vendor terminology for an LNE include logical
   system or logical router, and virtual switch, chassis, or fabric. Each
   LNE may also support virtual routing and forwarding (VRF) and virtual
   switching instance (VSI) functions, which are referred to below as a
   network instances (NIs). This breakdown is represented in
   Figure 1.
</t>
<t>
<figure>
<artwork>

           ,''''''''''''''''''''''''''''''''''''''''''''''`.
           |      Network Device (Physical or Virtual)     |
           | .....................   ..................... |
           | :  Logical Network  :   :  Logical Network  : |
           | :      Element      :   :      Element      : |
           | :+-----+-----+-----+:   :+-----+-----+-----+: |
           | :| Net | Net | Net |:   :| Net | Net | Net |: |
           | :|Inst.|Inst.|Inst.|:   :|Inst.|Inst.|Inst.|: |
           | :+-----+-----+-----+:   :+-----+-----+-----+: |
           | :  | |   | |   | |  :   :  | |   | |   | |  : |
           | :..|.|...|.|...|.|..:   :..|.|...|.|...|.|..: |
           |    | |   | |   | |         | |   | |   | |    |
            `'''|'|'''|'|'''|'|'''''''''|'|'''|'|'''|'|'''''
                | |   | |   | |         | |   | |   | |
                   Interfaces              Interfaces
</artwork>
</figure>
</t>
<t>
                 Figure 1: Module Element Relationships
</t>
<t>
   A model for LNEs is described in <xref target="I-D.ietf-rtgwg-lne-model"/> and
   the model for network instances is covered in <xref
   target="sec-NI"/>.
</t>
<t>
   The interface management model <xref target="RFC7223"/> is an
   existing model that is impacted by the definition of LNEs and
   network instances.  This document and <xref target="I-D.ietf-rtgwg-lne-model"/>
   define augmentations to the interface module to support LNEs
   and NIs.
</t>
<t>
   Interfaces are a crucial part of any network device's
   configuration and operational state.  They generally include a
   combination of raw physical interfaces, link-layer interfaces,
   addressing configuration, and logical interfaces that may not
   be tied to any physical interface.  Several system services,
   and layer 2 and layer 3 protocols may also associate
   configuration or operational state data with different types of
   interfaces (these relationships are not shown for simplicity).
   The interface management model is defined by <xref
   target="RFC7223"/>.  
</t>
<t>
   The network-instance module
   augments the existing interface management model by
   adding a name which is used on
   interface or sub-interface types to identify an associated
   network instance.
   Similarly, this name is also added for IPv4 and IPv6 types, as
   defined in <xref target="RFC7277"/>.
</t>
<t>
   The interface related augmentations is as follows:
<figure>
<artwork>
    module: ietf-network-instance
      augment /if:interfaces/if:interface:
        +--rw bind-network-instance-name?   ->
                          /network-instances/network-instance/name
      augment /if:interfaces/if:interface/ip:ipv4:
        +--rw bind-network-instance-name?   ->
                          /network-instances/network-instance/name
      augment /if:interfaces/if:interface/ip:ipv6:
        +--rw bind-network-instance-name?   ->
                          /network-instances/network-instance/name
</artwork>
</figure>
</t>
<t>
   The following is an example of envisioned usage.  The
   interfaces container includes a number of commonly used
   components as examples:
</t>
<t>
  <!-- TBD: Maybe use longer example from Xufeng -->
<figure>
<artwork>
          +--rw if:interfaces
          |  +--rw interface* [name]
          |     +--rw name                       string
          |     +--rw ethernet
          |     |  +--rw ni:bind-network-instance-name?   ->
                          /network-instances/network-instance/name
          |     |  +--rw aggregates
          |     |  +--rw rstp
          |     |  +--rw lldp
          |     |  +--rw ptp
          |     +--rw vlans
          |     +--rw tunnels
          |     +--rw ipv4
          |     |  +--rw ni:bind-network-instance-name?   ->
                          /network-instances/network-instance/name
          |     |  +--rw arp
          |     |  +--rw icmp
          |     |  +--rw vrrp
          |     |  +--rw dhcp-client
          |     +--rw ipv6
          |        +--rw ni:bind-network-instance-name?   ->
                          /network-instances/network-instance/name
          |        +--rw vrrp
          |        +--rw icmpv6
          |        +--rw nd
          |        +--rw dhcpv6-client
</artwork>
</figure>
</t>
<t>
   The <xref target="RFC7223"/> defined interface model is
   structured to include all interfaces in a flat list, without
   regard to virtual instances (e.g., VRFs) supported
   on the device.  The 
   bind-network-instance-name leaf provides the association
   between an interface and its associated NI (e.g., VRF
   or VSI).  Note that as currently
   defined, to assign an interface to both an LNE and NI, the interface
   would first be assigned to the LNE using the mechanisms defined in
   <xref target="I-D.ietf-rtgwg-lne-model"/>
   and then within that LNE's interface module, the LNE's representation
   of that interface would be assigned to an NI.
</t>
</section>

<section anchor="sec-NI" title="Network Instances">
<t>
   The network instance container is used to represent virtual routing
   and forwarding instances (VRFs) and virtual switching instances
   (VSIs), <xref target="RFC4026"/>.  VRFs and VSIs are commonly used to isolate
   routing and switching domains, for example to create virtual private
   networks, each with their own active protocols and routing/switching
   policies.  The model represents supports both core/provider and virtual
   instances.  Core/provider instance information is accessible at the
   top level of the server, while virtual instance information is
   accessible under the NI root schema mount point.
</t>
<t>
  The NI model can be represented using the tree format defined in <xref
   target="I-D.ietf-netmod-yang-tree-diagrams"/> as:
</t>
<t>
<figure>
<artwork>
module: ietf-network-instance
    +--rw network-instances
       +--rw network-instance* [name]
          +--rw name           string
          +--rw enabled?       boolean
          +--rw description?   string
          +--rw (ni-type)?
  augment /if:interfaces/if:interface:
    +--rw bind-ni-name?   -> /network-instances/network-instance/name
  augment /if:interfaces/if:interface/ip:ipv4:
    +--rw bind-ni-name?   -> /network-instances/network-instance/name
  augment /if:interfaces/if:interface/ip:ipv6:
    +--rw bind-ni-name?   -> /network-instances/network-instance/name

  notifications:
    +---n bind-ni-name-failed
       +--ro name          -> /if:interfaces/interface/name
       +--ro (interface-type)?
       |  +--:(interface)
       |  |  +--ro interface
       |  |     +--ro bind-ni-name
       |  |             -> /if:interfaces/interface/ni:bind-ni-name
       |  +--:(ipv4)
       |  |  +--ro ipv4
       |  |     +--ro bind-ni-name
       |  |             -> /if:interfaces/interface/ip:ipv4/ni:bind-ni-name
       |  +--:(ipv6)
       |     +--ro ipv6
       |        +--ro bind-ni-name
       |                -> /if:interfaces/interface/ip:ipv6/ni:bind-ni-name
       +--ro error-info?   string
</artwork>
</figure>
</t>
<t>
   A network instance is identified by a
   'name' string.  This string is used both as
   an index within the network-instance module and to associate
   resources with a network instance as shown above in the
   interface augmentation. Type is used to indicate the type NI,
   such as L3-VRF, VPLS, L2-VSI, etc. (TBD: Replace with choice, and per
   type case).
   Network instance policy
   and root are discussed in greater detail below.
   bind-lne-name-failed is used in certain failure cases.
</t>
<section anchor="sec-NI.1" title="  Network Instance Policy">
<t>
   Network instance policies are used to control how NI
   information is represented at the device level, VRF routing
   policies, and VRF/VSI identifiers. Examples include BGP route
   targets (RTs) and route distinguishers (RDs), virtual network
   identifiers (VN-IDs), VPLS neighbors, etc. The structure is
   expected to be:
</t>
<t>
<figure>
<artwork>
    module: ietf-network-instance
       +--rw network-instances
          +--rw network-instance* [name]
             +--rw network-instance-policy
                (TBD)
</artwork>
</figure>
</t>
</section>

<section anchor="sec-NI.2" title="Network Instance Management">
<t>
   Modules that may be used to represent network instance
   specific information will be available under
   'root'.  The
   use-schema mechanism defined as part of the Schema Mount module
   <xref target="I-D.ietf-netmod-schema-mount"/>
   MUST used with the module defined in this document to identify
   supported modules. 
   A future version of this document could relax this requirement.
   Mounted modules in the non-inline case SHOULD be defined with 
   access, via the appropriate schema mount parent-references <xref
   target="I-D.ietf-netmod-schema-mount"/>, to
   device resources such as interfaces.
</t>

<t>
    All modules that represent control-plane and data-plane
    information may be present at the 'root',
    and be accessible via paths modified per
    <xref target="I-D.ietf-netmod-schema-mount"/>.  The list of available
    modules is expected to be implementation dependent.  As is the
    method used by an implementation to support NIs.
</t>

<t>
  As an example, the following could be used to define support for
  an NI used to support VRFs which use OSPF <xref
  target="I-D.ietf-ospf-yang"/>:
</t>
<t>
  <figure>
    <artwork>
    "ietf-yang-schema-mount:schema-mounts": {
      "mount-point": [
        {
          "module": "ietf-network-instance",
          "name": "root",
          "use-schema": [
            {
              "name": "ni-schema",
              "parent-reference": [
                "/*[namespace-uri() = 'urn:ietf:...:ietf-interfaces']"
              ]
            }
          ]
        }
      ],
      "schema": [
        {
          "name": "ni-schema",
          "module": [
            {
               "name": "ietf-routing",
               "revision": "2016-11-04",
               "namespace":
                 "urn:ietf:params:xml:ns:yang:ietf-routing",
               "conformance-type": "implement"
             },
            {
               "name": "ietf-ospf",
               "revision": "2017-03-12",
               "namespace":
                 "urn:ietf:params:xml:ns:yang:ietf-ospf",
               "conformance-type": "implement"
            }
          ]
        }
      ]
    }
    </artwork>
  </figure>
</t>
<t>
  The resulting full module tree representation would be:
</t>
<t>
<figure>
  <artwork>
   module: ietf-network-instance
   +--rw network-instances
      +--rw network-instance* [name]
         +--rw name                       string
         +--rw type?                      identityref
         +--rw enabled?                   boolean
         +--rw description?               string
         +--rw network-instance-policy
         +--rw root?          yangmnt:mount-point
            // module: ietf-routing
            +--ro routing-state
            |  +--ro router-id?                 yang:dotted-quad
            |  +--ro control-plane-protocols
            |  |  +--ro control-plane-protocol* [type name]
            |        // module: ietf-ospf
            |         +--ro ospf
            |           +--ro instance* [af]
            +--rw routing
               +--rw router-id?                 yang:dotted-quad
               +--rw control-plane-protocols
               |  +--rw control-plane-protocol* [type name]
               |  // module: ietf-ospf
               |     +--rw ospf:ospf
               |        +--rw ospf:instance* [af]
               |           +--rw ospf:areas
               |           |  +--rw ospf:area* [area-id]
               |           |     +--rw ospf:interfaces
               |           |        +--rw ospf:interface* [name]
               |           |           +--rw ospf:name
                                                   if:interface-ref
               |           |           +--rw ospf:cost?   uint16
            // module: ietf-interfaces
            // access is enabled by parent-reference in the YANG
            // schema mount.
</artwork>
</figure>
</t>
</section>

<section anchor="sec-NI.3" title="  Network Instance Instantiation">
  <t>
    Network instances may be controlled by clients using existing list
    operations.  When list entries are created, a new instance is
    instantiated. The models mounted under a NI root is expected to be
    dependent on the server implementation.  When a list entry is
    deleted, an existing network instance is destroyed. For more
    information see <xref target="RFC7950"/> Section 7.8.6.
  </t>  
  <t>
    Once instantiated, host network device resources can be
    associated with the new NI.  As previously mentioned, this
    document augments ietf-interfaces with the bind-ni-name leaf
    to support such associations for interfaces.  When an
    bind-ni-name is set to a valid NI name, an implementation
    MUST take whatever steps are internally necessary to assign
    the interface to the NI or provide an error message (defined
    below) with an indication of why the assignment failed.  It is
    possible for the assignment to fail while processing the set, or
    after asynchronous processing.  Error notification in the latter
    case is supported via a notification.
  </t>
</section>
</section>
<section anchor="sec-4" title="Security Considerations">
  <t>
    There are two different sets of security considerations to consider
    in the context of this document.  One set is security related to
    information contained within mounted modules.  The security
    considerations for mounted modules is not substantively changed
    based on the information being accessible within the context of an
    NI.  For example, when considering the modules defined in <xref
    target="RFC8022"/>, the security considerations identified in that
    document are equally applicable, whether those modules are accessed
    at a server's root or under an NI instances root node.
  </t>
  <t>
    The second area for consideration is information contained in the NI
    module itself.  NI information represents network configuration and
    route distribution policy information. As such, the security of this
    information is important, but it is fundamentally no different than
    any other interface or routing configuration information that has
    already been covered in <xref target="RFC7223"/> and <xref
    target="RFC8022"/>.
  </t>
  <t>The vulnerable "config true" parameters and subtrees are the
  following:
  <list style="hanging">
    <t hangText="/network-instances/network-instance:">
      This list specifies the network instances and the related control
      plane protocols configured on a device.
    </t>
    <t hangText="/if:interfaces/if:interface/*/bind-network-instance-name:">
      This leaf indicates the NI instance to which an interface is
      assigned.
    </t>
  </list>
  Unauthorized access to any of these lists can adversely affect the
  routing subsystem of both the local device and the network. This
  may lead to network malfunctions, delivery of packets to
  inappropriate destinations and other problems.
  </t>
</section>

<section anchor="sec-5" title="  IANA Considerations">
  <t>
    This document registers a URI in the IETF XML registry <xref
    target="RFC3688"/>.  Following the format in RFC 3688, the following
    registration is requested to be made.
  </t>
  <figure>
    <artwork><![CDATA[
     URI: urn:ietf:params:xml:ns:yang:ietf-network-instance

     Registrant Contact: The IESG.

     XML: N/A, the requested URI is an XML namespace.
     ]]></artwork>
  </figure>
  <t>
    This document registers a YANG module in the YANG Module Names
    registry <xref target="RFC6020"/>.
  </t>
  <figure>
    <artwork><![CDATA[
  name:        ietf-network-instance
  namespace:   urn:ietf:params:xml:ns:yang:ietf-network-instance
  prefix:      ni
  reference:   RFC XXXX
  ]]></artwork>
  </figure>
</section>

<section anchor="sec-6.3" title="  Network Instance Model">
<t>
   The structure of the model defined in this document is described
   by the YANG module below.
</t>
<t>
<figure>
<artwork><![CDATA[
<CODE BEGINS> file "ietf-network-instance@2017-06-29.yang"
module ietf-network-instance {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-network-instance";
  prefix ni;

  // import some basic types

  import ietf-interfaces {
    prefix if;
    reference "RFC 7223: A YANG Data Model for Interface Management";
  }
  import ietf-ip {
    prefix ip;
    reference "RFC 7277: A YANG Data Model for IP Management";
  }
  import ietf-yang-schema-mount {
    prefix yangmnt;
    reference "draft-ietf-netmod-schema-mount: YANG Schema Mount";
    // RFC Ed.: Please replace this draft name with the corresponding
    // RFC number
  }

  organization
    "IETF Routing Area (rtgwg) Working Group";
  contact
    "WG Web:   <http://tools.ietf.org/wg/rtgwg/>
     WG List:  <mailto:rtgwg@ietf.org>

     Author:   Lou Berger
               <mailto:lberger@labn.net>
     Author:   Christan Hopps
               <mailto:chopps@chopps.org>
     Author:   Acee Lindem
               <mailto:acee@cisco.com>
     Author:   Dean Bogdanovic
               <mailto:ivandean@gmail.com>";
  description
    "This module is used to support multiple network instances
     within a single physical or virtual device.  Network
     instances are commonly know as VRFs (virtual routing
     and forwarding) and VSIs (virtual switching instances).

     Copyright (c) 2017 IETF Trust and the persons
     identified as authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX; see
     the RFC itself for full legal notices.";

  // RFC Ed.: replace XXXX with actual RFC number and remove
  // this note
  // RFC Ed.: please update TBD

  revision 2017-06-23 {
    description
      "Initial revision.";
    reference "RFC TBD";
  }

  // identity statements

  identity ni-types {
    description
      "Base identity from which types used in the ni-type 
      choice statement are defined. The primary purpose
      of this identity is to support a companion IANA
      registry to ensure two modules don't define the
      same ni-type";
  }

  // top level device definition statements

  container network-instances {
    description
      "Network instances each of which consists of a
       VRFs (virtual routing and forwarding) and/or
       VSIs (virtual switching instances).";
    reference "RFC 8022 - A YANG Data Model for Routing Management";
    list network-instance {
      key "name";
      description
        "List of network-instances.";
      leaf name {
        type string;
        description
          "device scoped identifier for the network
           instance.";
      }
      leaf enabled {
        type boolean;
        default "true";
        description
          "Flag indicating whether or not the network
           instance is enabled.";
      }
      leaf description {
        type string;
        description
          "Description of the network instance
           and its intended purpose.";
      }
      choice ni-type {
        description
	  "This node serves as an anchor point for different types of
	   network instances.  Each 'case' is expected to differ in
	   terms of the information need in the parent/core to support
	   the NI, and may differ in their mounted schema definition.
	   When the mounted schema is expected to be the same for
	   different types of NIs, they may share the same mount
	   point name and consequently may share schemas.";
      }
    }
  }

  // augment statements

  augment "/if:interfaces/if:interface" {
    description
      "Add a node for the identification of the network
       instance associated with the information configured
       on a interface.

       Note that a standard error will be returned if the
       identified leafref isn't present.  If an interfaces cannot
       be assigned for any other reason, the operation SHALL fail
       with an error-tag of 'operation-failed' and an error-app-tag
       of 'ni-assignment-failed'.  A meaningful error-info that
       indicates the source of the assignment failure SHOULD also
       be provided.";
    leaf bind-ni-name {
      type leafref {
        path "/network-instances/network-instance/name";
      }
      description
        "Network Instance to which an interface is bound.";
    }
  }
  augment "/if:interfaces/if:interface/ip:ipv4" {
    description
      "Add a node for the identification of the network
       instance associated with the information configured
       on an IP interface.

       Note that a standard error will be returned if the
       identified leafref isn't present.  If an interfaces cannot
       be assigned for any other reason, the operation SHALL fail
       with an error-tag of 'operation-failed' and an error-app-tag
       of 'ni-assignment-failed'.  A meaningful error-info that
       indicates the source of the assignment failure SHOULD also
       be provided.";
    leaf bind-ni-name {
      type leafref {
        path "/network-instances/network-instance/name";
      }
      description
        "Network Instance to which IPv4 interface is bound.";
    }
  }
  augment "/if:interfaces/if:interface/ip:ipv6" {
    description
      "Add a node for the identification of the network
       instance associated with the information configured
       on an IP interface.

       Note that a standard error will be returned if the
       identified leafref isn't present.  If an interfaces cannot
       be assigned for any other reason, the operation SHALL fail
       with an error-tag of 'operation-failed' and an error-app-tag
       of 'ni-assignment-failed'.  A meaningful error-info that
       indicates the source of the assignment failure SHOULD also
       be provided.";
    leaf bind-ni-name {
      type leafref {
        path "/network-instances/network-instance/name";
      }
      description
        "Network Instance to which IPv6 interface is bound.";
    }
  }

  // notification statements

  notification bind-ni-name-failed {
    description
      "Indicates an error in the association of an interface to an
       NI. Only generated after success is initially returned when
       bind-ni-name is set.";
    leaf name {
      type leafref {
        path "/if:interfaces/if:interface/if:name";
      }
      mandatory true;
      description
        "Contains the interface name associated with the
        failure.";
    }
    choice interface-type {
      description
        "Interface type that contained the bind-ni-name.";
      container interface {
        description
          "Generic interface type.";
        leaf bind-ni-name {
          type leafref {
            path "/if:interfaces/if:interface/ni:bind-ni-name";
          }
          mandatory true;
          description
            "Contains the bind-ni-name associated with the
             failure.";
        }
      }
      container ipv4 {
        description
          "IPv4 interface type.";
        leaf bind-ni-name {
          type leafref {
            path "/if:interfaces/if:interface/ip:ipv4/ni:bind-ni-name";
          }
          mandatory true;
          description
            "Contains the bind-ni-name associated with the
             failure.";
        }
      }
      container ipv6 {
        description
          "IPv6 interface type.";
        leaf bind-ni-name {
          type leafref {
            path "/if:interfaces/if:interface/ip:ipv6/ni:bind-ni-name";
          }
          mandatory true;
          description
            "Contains the bind-ni-name associated with the
             failure.";
        }
      }
    }
    leaf error-info {
      type string;
      description
        "Optionally, indicates the source of the assignment
         failure.";
    }
  }
}
<CODE ENDS>
]]></artwork>
</figure>
</t>
</section>
</middle>

<?rfc needLines="20"?>
<back>
<references title="Normative References">

  <?rfc include="reference.I-D.ietf-rtgwg-lne-model.xml"?>
  <?rfc include="reference.I-D.ietf-netmod-schema-mount.xml"?>
  <?rfc include="reference.RFC.6020"?>
  <?rfc include="reference.RFC.7223"?>
  <?rfc include="reference.RFC.7277"?>
  <?rfc include="reference.RFC.3688"?>

</references>

<references title="Informative References">

<?rfc include="reference.I-D.ietf-netmod-yang-tree-diagrams.xml"?>
<?rfc include="reference.I-D.ietf-rtgwg-device-model.xml"?>
<?rfc include="reference.I-D.ietf-ospf-yang.xml"?>
<?rfc include="reference.RFC.4026"?>
<?rfc include="reference.RFC.7950"?>
<?rfc include="reference.RFC.8022"?>

</references>

<?rfc needLines="100"?>
<section title="Acknowledgments">
   <t>The Routing Area Yang Architecture design team members included Acee
   Lindem, Anees Shaikh, Christian Hopps, Dean Bogdanovic, Lou Berger,
   Qin Wu, Rob Shakir, Stephane Litkowski, and Yan Gang. Useful review
   comments were also received by Martin Bjorklund and John Scudder.</t>

<t>
   This document was motivated by, and derived from,
   <xref target="I-D.ietf-rtgwg-device-model"/>.
</t>

  <t>The RFC text was produced using Marshall Rose's xml2rfc tool.
   <vspace blankLines="100"/></t>
</section>
</back>

</rfc>

<!-- Local Variables: -->
<!-- fill-column:72 -->
<!-- End: -->
